'''
2). Написать два алгоритма нахождения i-го по счёту простого числа.
Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число.
Проанализировать скорость и сложность алгоритмов.

Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.

Второй — без использования «Решета Эратосфена».


Анализ:
Вариант с использованием Решета Эратосфена в разы быстрее варианта реализованного без решета.
Оба алгоритма имеют линейную сложность - O(n).


'''

##########################################_____С использованием Решена_____#############################################

import timeit
import cProfile


def sieve(num):
    len_num = len(str(num))

    n = int(num * (3 + ((2.45 * (len_num - 1)) * (1 + len_num / 6))))  # 3 - это: 10 простых чисел входят в 30 первых
    # натуральных чисел, 30 / 10 = 3 - коэфициент k, при каждом увеличении простых чисел на 10 коэфициент k
    # увеличивается немного больше чем на 2,45 (2,45 - увеличение коэфициента k при 100 числах),
    # (len_num - 1) - это сколько раз искомое простое число увеличило свой порядок на 10, чтобы учесть это немного большее увеличение
    # чем на 2,45 добавил еще один коэфициент (1 + (len_num)/6), за счет того что он зависит от len_num
    # исключается ситуация когда при многократном увеличении искомого простого числа алгоритм возьмет
    # меньшее количество натуральных чисел чем нужно

    a = [0] * n

    for i in range(n):
        a[i] = i

    a[1] = 0
    m = 2

    while m < n:
        if a[m] != 0:
            j = m * 2
            while j < n:
                a[j] = 0
                j = j + m
        m += 1

    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])

    return b[num - 1]


# print(sieve(100))
# print(sieve(1000))

print(timeit.timeit('sieve(10)', number=1000, globals=globals()))  # 0.0145933
print(timeit.timeit('sieve(100)', number=1000, globals=globals()))  # 0.3033083
print(timeit.timeit('sieve(1_000)', number=1000, globals=globals()))  # 6.3858606
print(timeit.timeit('sieve(10_000)', number=1000, globals=globals()))  # 125.4141552

cProfile.run('sieve(4000)')

#       6150 function calls in 0.026 seconds
#
# Ordered by: standard name
#
# ncalls  tottime  percall  cumtime  percall filename:lineno(function)
#      1    0.001    0.001    0.026    0.026 <string>:1(<module>)
#      1    0.024    0.024    0.025    0.025 test.py:19(sieve)
#      1    0.000    0.000    0.026    0.026 {built-in method builtins.exec}
#      1    0.000    0.000    0.000    0.000 {built-in method builtins.len}
#   6145    0.001    0.000    0.001    0.000 {method 'append' of 'list' objects}
#      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
